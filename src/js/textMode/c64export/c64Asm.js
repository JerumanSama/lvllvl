// before char effects
//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\n\n; frame info..\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors...\n        lda next_color_frame_bg1\n        sta $d021       ; background color\n        lda next_color_frame_bg2\n        sta $d022       ; background color\n        lda next_color_frame_bg3\n        sta $d023       ; background color\n        lda next_color_frame_bg4\n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";

//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\n\n; frame info..\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n;        jsr animate_chars\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors...\n        lda next_color_frame_bg1\n        sta $d021       ; background color\n        lda next_color_frame_bg2\n        sta $d022       ; background color\n        lda next_color_frame_bg3\n        sta $d023       ; background color\n        lda next_color_frame_bg4\n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\nanimate_chars\n;\tinc $d020\n  lda #$38\n  sta temp_high\n  lda #$00\n  sta temp_low\n  \n\tjsr scroll_char_down\n;  dec $d020\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$07\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$07\nscroll_char_left_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n  bne scroll_char_left_cont\n\n\trts\n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";
var C64ASMScroll = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\nvertical_scroll         = $66\nvertical_char_offset_high = $67\nvertical_char_offset_low  = $68\n\n\n; frame info..\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\n\n; need to store location of current frame info for scroll routine\ncurrent_char_frame_addr_low    = $0bf5\ncurrent_char_frame_addr_high   = $0bf6\ncurrent_color_frame_addr_low   = $0bf7\ncurrent_color_frame_addr_high  = $0bf8\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        \n        lda frame_ptr_start_high\n        sta first_frame_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        ; init vertical scroll\n        ; turn on 24 rows\n        lda $d011\n        and #$f0\n        sta $d011\n\n\t\t\t\t; initial scroll is 7\n        lda #$07\n        sta vertical_scroll\n\n\t\t\t\tlda #$00\n        sta vertical_char_offset_high\n        lda #$00\n\t\t\t\tsta vertical_char_offset_low\n        \n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick2\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n\n\t\t\t\tjsr vertical_scroll_up\n        \n;        rts\n        \n        ; delay counter was initialised to number of ticks the current frame is to be displayed for\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n\n        ; frame has finished, reset tick counter\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n\n\t\t\t\t; call any effects routines that need to update each on tick\n\t\t\t\tjsr effects_tick\n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick2\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick4\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick5\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n;        jsr swap_buffers\n\n        ; update colors...\n;        lda next_color_frame_bg1\n;        sta $d021       ; background color\n;        lda next_color_frame_bg2\n;        sta $d022       ; background color\n;        lda next_color_frame_bg3\n;        sta $d023       ; background color\n;        lda next_color_frame_bg4\n;        sta $d024       ; background color\n\n\n\t\t\t\t; update current pointer to the next pointers\n\t\t\t\tlda next_char_frame_addr_low\n        sta current_char_frame_addr_low\n        lda next_char_frame_addr_high\n        sta current_char_frame_addr_high\n\n        lda next_color_frame_addr_low\n        sta current_color_frame_addr_low\n        lda next_color_frame_addr_high\n        sta current_color_frame_addr_high\n\n\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n\n\t\t\t\t; set the offset into the data for vertical scroll\n\t\t\t\tclc\n        lda copy_from_low\n        adc vertical_char_offset_low\n        sta copy_from_low\n        \n        lda copy_from_high\n        adc vertical_char_offset_high\n        sta copy_from_high\n\n\n;        jsr copy_data\n        jmp read_effects         ; read the effects for this frame\n\n\n        \n        \n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick2\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n\t\t\t\t; set the offset into the data for vertical scroll\n\t\t\t\tclc\n        lda copy_from_low\n        adc vertical_char_offset_low\n        sta copy_from_low\n        \n        lda copy_from_high\n        adc vertical_char_offset_high\n        sta copy_from_high\n        \n\n;        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick4\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick4done\n\n        jsr data_changes\n\ntick4done\n        rts\ntick5\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc FRAMEWIDTHLOW                ; add FRAMEWIDTH with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc FRAMEWIDTHHIGH\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\n\nvertical_scroll_up\n\n\t; display delay counter for info\n\tlda delay_counter\n;  sta $440\n;  sta $840\n\n\t; scroll up by one pixel\n  dec vertical_scroll\n  \n  ; set the scroll register\n  lda $d011\n  ; dont want to 'and' the position of the raster, so dont use bit 7\n  and #$70\n  ora vertical_scroll\n  sta $d011\n  \n\n\t; check if need to update the offsets\n  lda vertical_scroll\n  cmp #$00\n  bne check_delay_counter0\n  \n  \n  ; reset vertical scroll\n  lda #$08\n  sta vertical_scroll\n  \n  ; on last pixel of current character\n\n\t; update offset into map\n  clc\n  lda vertical_char_offset_low\n  adc FRAMEWIDTHLOW\n  sta vertical_char_offset_low\n  \n  lda vertical_char_offset_high\n  adc FRAMEWIDTHHIGH\n  sta vertical_char_offset_high\n  \n  \n  ;; need to reset it?\n  lda vertical_char_offset_high\n  cmp VERTICALSCROLLMAXHIGH\n  bne check_delay_counter0\n  \n  lda vertical_char_offset_low\n  cmp VERTICALSCROLLMAXLOW\n  bne check_delay_counter0\n  \n  lda #$00\n  sta vertical_char_offset_high\n  sta vertical_char_offset_low\n  \n  \n\n\ncheck_delay_counter0\n\n  lda delay_counter\n  cmp #$02\n  bne check_delay_counter1\n  \n  \n  ; workaround\n\tlda vertical_scroll\n  cmp #$07\n  bne continue_check_delay_counter0\n  lda #$00\n  sta vertical_scroll\n  \n  \n  ; set the scroll register\n  lda $d011\n  ; dont want to 'and' the position of the raster, so dont use bit 7\n  and #$70\n  ora vertical_scroll\n  sta $d011\n  \n  lda #$08\n  sta vertical_scroll\n\ncontinue_check_delay_counter0  \n\n\n  ; delay counter is 2, next frame will be displayed next time\n  \n  lda next_char_frame_addr_low\n  sta copy_from_low\n  lda next_char_frame_addr_high\n  sta copy_from_high\n  \n  jmp scroll_copy_to_back_buffer\n    \n  \ncheck_delay_counter1  \n  lda delay_counter\n  cmp #$01\n  bne check_vertical_scroll1\n    \n    \n\n  lda next_color_frame_bg1\n  sta $d021       ; background color\n  lda next_color_frame_bg2\n  sta $d022       ; background color\n  lda next_color_frame_bg3\n  sta $d023       ; background color\n  lda next_color_frame_bg4\n  sta $d024       ; background color\n\n\n\n\n  ; copy color data\n  lda next_color_frame_addr_low\n  sta copy_from_low\n  lda next_color_frame_addr_high\n  sta copy_from_high\n\n\tjmp scroll_swap_buffers\n  \n  \n  \ncheck_vertical_scroll1\n\tlda vertical_scroll\n  cmp #$08\n  bne check_vertical_scroll2\n  \n  ; need to copy into back buffer\n  ; load in location of current character data\n  lda current_char_frame_addr_low\n  sta copy_from_low\n  lda current_char_frame_addr_high\n  sta copy_from_high\n  \n\nscroll_copy_to_back_buffer\n  ; copy to the back buffer\n  lda #$00\n  sta copy_to_low\n  lda back_buffer_high\n  sta copy_to_high\n\n  ; need to add in the offset\n  clc\n  lda copy_from_low\n  adc vertical_char_offset_low\n  sta copy_from_low\n        \n  lda copy_from_high\n  adc vertical_char_offset_high\n  sta copy_from_high\n       \n       \n  ; copy the data\n  jsr copy_data\n\n\trts\n  \n  \n  \ncheck_vertical_scroll2\n\tlda vertical_scroll\n  cmp #$07\n  bne vertical_scroll_done\n  \n  ; need to swap buffers and copy color data\n  lda current_color_frame_addr_low\n  sta copy_from_low\n  lda current_color_frame_addr_high\n  sta copy_from_high\n  \n\nscroll_swap_buffers\n  ; start of new character, need to swap buffers\n  jsr swap_buffers\n\n\t; copying to color buffer\n  lda #$00\n  sta copy_to_low\n  lda #$d8\n  sta copy_to_high\n\n  ; set the offset into the data for vertical scroll\n  clc\n  lda copy_from_low\n  adc vertical_char_offset_low\n  sta copy_from_low\n        \n  lda copy_from_high\n  adc vertical_char_offset_high\n  sta copy_from_high\n\n  jsr copy_data\n\n\n  rts\n  \n  \n  \nvertical_scroll_done  \n  rts\n  \ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\ninit_effects\n\trts\n  \n\n";

// working
//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\n\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n;        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors...\n        lda next_color_frame_bg1\n        sta $d021       ; background color\n        lda next_color_frame_bg2\n        sta $d022       ; background color\n        lda next_color_frame_bg3\n        sta $d023       ; background color\n        lda next_color_frame_bg4\n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n;\tinc $d021\n;  inc $d022\n;  inc $d023\n;  inc $d024\n \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";


//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\n\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n;        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors...\n\n\t\t\t\tldy #$00\n\t\t\t\t; color table starts at $4000\n        lda #$40\n        sta temp_high\n        \n        lda next_color_frame_bg1\n        sta temp_low        \n        lda (temp_low), y\n        sta $d021       ; background color\n        lda next_color_frame_bg2\n;        sta temp_low\n;        lda (temp_low), y\n        sta $d022       ; background color\n        \n        lda next_color_frame_bg3\n        sta $d023       ; background color\n        lda next_color_frame_bg4\n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\ncolor_table\n\n\n!byte $00,$01,$02,$03,$04,$05,$06,$07\n!byte $08,$09,$0a,$0b,$0c,$0d,$0e,$0f\n\n*= $4010\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n;\tinc $d021\n;  inc $d022\n;  inc $d023\n;  inc $d024\n \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";

//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\n\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n;        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors\n\n\t\t\t\tldy #$00\n        ; update background colors using color table\n\t\t\t\t; color table starts at $4000\n        lda #$40\n        sta temp_high\n        \n        lda next_color_frame_bg1\n        sta temp_low        \n        lda (temp_low), y\n        sta $d021       ; background color\n        \n        lda next_color_frame_bg2\n        sta temp_low\n        lda (temp_low), y\n        sta $d022       ; background color\n        \n        lda next_color_frame_bg3\n        sta temp_low\n        lda (temp_low), y\n        sta $d023       ; background color\n\n\t\t\t\tlda next_color_frame_bg4\n        sta temp_low\n        lda (temp_low), y        \n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\ncolor_table\n\n\n!byte $00,$01,$02,$03,$04,$05,$06,$07\n!byte $08,$09,$0a,$0b,$0c,$0d,$0e,$0f\n\n*= $4010\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n;\tinc $d021\n;  inc $d022\n;  inc $d023\n;  inc $d024\n \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";

//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\ncurrent_color_frame_bg1     = $0bf9\ncurrent_color_frame_bg2     = $0bfa\ncurrent_color_frame_bg3     = $0bfb\ncurrent_color_frame_bg4     = $0bfc\n\n\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors\n\n        \n        lda next_color_frame_bg1\n        sta current_color_frame_bg1\n        lda next_color_frame_bg2\n        sta current_color_frame_bg2\n        lda next_color_frame_bg3\n        sta current_color_frame_bg3\n        lda next_color_frame_bg4\n        sta current_color_frame_bg4\n        \n\n\t\t\t\tldy #$00\n        ; update background colors using color table\n\t\t\t\t; color table starts at $4000\n        lda #$40\n        sta temp_high\n        \n\t\t\t\tlda next_color_frame_bg1\n        sta temp_low        \n        lda (temp_low), y\n        sta $d021       ; background color\n        \n        lda next_color_frame_bg2\n        sta temp_low\n        lda (temp_low), y\n        sta $d022       ; background color\n        \n        lda next_color_frame_bg3\n        sta temp_low\n        lda (temp_low), y\n        sta $d023       ; background color\n\n\t\t\t\tlda next_color_frame_bg4\n        sta temp_low\n        lda (temp_low), y        \n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\ncolor_table\n\n\n!byte $00,$01,$02,$03,$04,$05,$06,$07\n!byte $08,$09,$0a,$0b,$0c,$0d,$0e,$0f\n\n*= $4010\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n\tinc $4000\n  inc $4001\n  inc $4002\n  inc $4003\n  \n\n  ldy #$00\n  ; update background colors using color table\n  ; color table starts at $4000\n  lda #$40\n  sta temp_high\n\n  lda current_color_frame_bg1\n  sta temp_low        \n  lda (temp_low), y\n  sta $d021       ; background color\n\n  lda current_color_frame_bg2\n  sta temp_low\n  lda (temp_low), y\n  sta $d022       ; background color\n\n  lda current_color_frame_bg3\n  sta temp_low\n  lda (temp_low), y\n  sta $d023       ; background color\n\n  lda current_color_frame_bg4\n  sta temp_low\n  lda (temp_low), y        \n  sta $d024       ; background color\n\n\n\trts \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";

//var C64ASM = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\ncurrent_color_frame_bg1     = $0bf9\ncurrent_color_frame_bg2     = $0bfa\ncurrent_color_frame_bg3     = $0bfb\ncurrent_color_frame_bg4     = $0bfc\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n;        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        lda next_color_frame_bg1\n        sta current_color_frame_bg1\n        lda next_color_frame_bg2\n        sta current_color_frame_bg2\n;        lda next_color_frame_bg3\n;        sta current_color_frame_bg3\n;        lda next_color_frame_bg4\n;        sta current_color_frame_bg4\n        \n\n;        ldy #$00\n        ; update background colors using color table\n        ; color table starts at $4000\n        lda #$40\n        sta copy_from_high2 \n        \n        lda next_color_frame_bg1\n;        sta copy_from_low2        \n;        lda (copy_from_low2), y\n        sta $d021       ; background color\n        \n        lda next_color_frame_bg2\n;        sta copy_from_low2\n;        lda (copy_from_low2), y\n        sta $d022       ; background color\n        \n        lda next_color_frame_bg3\n;        sta copy_from_low2\n;        lda (copy_from_low2), y\n        sta $d023       ; background color\n\n        lda next_color_frame_bg4\n;        sta copy_from_low2\n;        lda (copy_from_low2), y        \n        sta $d024       ; background color\n\n\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\ncolor_table\n\n!byte $00,$01,$02,$03,$04,$05,$06,$07\n!byte $08,$09,$0a,$0b,$0c,$0d,$0e,$0f\n\n*= $4010\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n;\tinc $d021\n;  inc $d022\n;  inc $d023\n;  inc $d024\n \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";
//

// with multi colour
//var C64ASMSource = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\n\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n        lda extended_color_mode\n        cmp #$01\n        bne setup_custom_chars\n\nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n;\t\t\t\tora #$10\n        sta $d016\n        \n;        lda #$08\n;        sta $d022\n        \n;        lda #$07\n;        sta $d023\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n;        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors...\n        lda next_color_frame_bg1\n        sta $d021       ; background color\n        lda next_color_frame_bg2\n        sta $d022       ; background color\n        lda next_color_frame_bg3\n        sta $d023       ; background color\n        lda next_color_frame_bg4\n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n;\tinc $d021\n;  inc $d022\n;  inc $d023\n;  inc $d024\n \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";


var C64ASMSource = "*=$801\nbasic_start_code\n!byte    $0B, $08, $0A, $00, $9E, $32, $30, $38, $30, $00, $00, $00\n\n; zero page \ncopy_from_low           = $4d\ncopy_from_high          = $4e\n\ncopy_to_low             = $4f\ncopy_to_high            = $50\n\nframe_finished          = $51\n\nback_buffer_high        = $52\nfront_buffer_high       = $53\n\nframe_ptr_low           = $54\nframe_ptr_high          = $55\n\ndelay_counter           = $56\n\ntemp                    = $57\nch1_in_new_note         = $58\nch2_in_new_note         = $59\nch3_in_new_note         = $5a\ntick                    = $5c\n\ntemp_low                = $5d\ntemp_high               = $5e\ncheck_keys_enabled      = $5f\nkey_table_low           = $60\nkey_table_high          = $61\ncheck_instr_enabled     = $62\ninstr_table_low         = $63\ninstr_table_high        = $64\n\ntrig                    = $65\n\ncopy_from_low2           = $66\ncopy_from_high2          = $67\n\ncopy_to_low2             = $68\ncopy_to_high2            = $69\n\n; frame info.. can fit this in just after init code\nfirst_frame_low             = $0be8\nfirst_frame_high            = $0be9\n\nnext_char_frame_type        = $0bea\nnext_char_frame_addr_low    = $0beb\nnext_char_frame_addr_high   = $0bec\nnext_char_frame_delay       = $0bed\nnext_color_frame_type       = $0bee\nnext_color_frame_addr_low   = $0bef\nnext_color_frame_addr_high  = $0bf0\nnext_color_frame_bg1        = $0bf1\nnext_color_frame_bg2        = $0bf2\nnext_color_frame_bg3        = $0bf3\nnext_color_frame_bg4        = $0bf4\n\nanimated_chars_table_low    = $0bf5\nanimated_chars_table_high   = $0bf6\n\nanimated_bg_colors_table_low    = $0bf7\nanimated_bg_colors_table_high   = $0bf8\n\n\n\nch1_newnote                 = $1485\nch1_tempo                   = $149a\nch1_counter                 = $149b\nch1_note                    = $149c\nch1_instr                   = $149d\nch1_gate                    = $149e\n\nch2_tempo                   = $14a1\nch2_counter                 = $14a2\nch2_note                    = $14a3\nch2_instr                   = $14a4\nch2_gate                    = $14a5\n\nch3_tempo                   = $14a8\nch3_counter                 = $14a9\nch3_note                    = $14aa\nch3_instr                   = $14ab\nch3_gate                    = $14ac\n\n; config\n*= $0810\nconfig_values\n\nborder_color\n;        BYTE   $02    \n!byte   $02     \nextended_color_mode\n;        BYTE   $01\n!byte   $00\ncustom_chars \n;        BYTE   $00\n!byte   $00\n\nsid \n;        BYTE   $00\n!byte   $00\n\nsidspeed\n;        BYTE   $01\n!byte   $01\n\nsid_init_addr_low\n;        BYTE   $03\n!byte   $00\nsid_init_addr_high\n;        BYTE   $10\n!byte   $10\n\nsid_play_addr_low\n;        BYTE   $12\n!byte   $03\nsid_play_addr_high\n;        BYTE   $10\n!byte   $10\n\n\nframe_ptr_start_low\n;        BYTE   $00\n!byte   $00\nframe_ptr_start_high\n;        BYTE   $80\n!byte   $80\n\nanimated_chars_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_chars_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\nanimated_bg_colors_table_start_low\n; \t\t\t BYTE   $00\n!byte   $00\nanimated_bg_colors_table_start_high\n;\t\t\t\t BYTE   $00\n!byte   $00\n\n; init code, only run once\n*= $0820\ninit_code\n        ;$01=$36 -> RAM       visible A000-C000, IO visible at D000-E000, Kernal Rom Visible at E000-FFFF\n        lda #$36        ; $36 = 0011 0110\n        sta $01         ; RAM visible at $A000-$BFFF; KERNAL ROM visible at $E000-$FFFF, I/O area visible at $D000-$DFFF. \n\n        ; store location of frame ptrs\n        lda frame_ptr_start_low\n        sta first_frame_low\n        lda frame_ptr_start_high\n        sta first_frame_high\n        \n        lda animated_chars_table_start_low\n        sta animated_chars_table_low\n        lda animated_chars_table_start_high\n        sta animated_chars_table_high\n\n        lda animated_bg_colors_table_start_low\n        sta animated_bg_colors_table_low\n        lda animated_bg_colors_table_start_high\n        sta animated_bg_colors_table_high\n\n\n        lda border_color\n        sta $d020       ; border color\n\n\n        ; turn off multicolor mode\n        lda $d016\n        and #$ef\n        sta $d016\n        \n        lda extended_color_mode\n        cmp #$01\n        bne test_multi_color\n  \nsetup_extended_color_mode\n        lda $d011    ; turn on extended color mode\n        ora #$40\n        sta $d011\n        jmp setup_custom_chars\n\n\ntest_multi_color\n        cmp #$02\n        bne setup_custom_chars\n\nsetup_multi_color_mode\n        lda $d016    ; turn on extended color mode\n        ora #$10\n        sta $d016\n\n\nsetup_custom_chars\n\n        lda custom_chars\n        cmp #$01\n        bne setup_sid\n\n        lda $d018       \n        ora #$0e\n        sta $d018\n\nsetup_sid\n\n        lda sid\n        cmp #$01\n        bne disable_sid\n\n        lda sid_init_addr_low\n        sta sid_init_jsr+1\n        lda sid_init_addr_high\n        sta sid_init_jsr+2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr+1\n        lda sid_play_addr_high\n        sta sid_play_jsr+2\n\n        lda sidspeed\n        cmp #$01\n        beq disable_sid_speed2\n\n        lda sid_play_addr_low\n        sta sid_play_jsr2+1\n        lda sid_play_addr_high\n        sta sid_play_jsr2+2\n\n        jmp setup_screen\n\ndisable_sid\n        ; put NOP in the sid init and play instructions\n        lda #$ea \n        sta sid_init_jsr\n        sta sid_init_jsr+1\n        sta sid_init_jsr+2\n\n        sta sid_play_jsr\n        sta sid_play_jsr+1\n        sta sid_play_jsr+2\n\ndisable_sid_speed2\n        lda #$ea \n        sta sid_play_jsr2\n        sta sid_play_jsr2+1\n        sta sid_play_jsr2+2\n\n\nsetup_screen\n        ; set the screen location to 0400    xxx1 xxxx\n        lda $d018\n        and #$0f                  \n        ora #$10                  \n        sta $d018\n\n        ; front buffer is 0400, back buffer is 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n\n        lda #$00\n        sta ch1_in_new_note\n        sta ch2_in_new_note\n        sta ch3_in_new_note\n\n        ;; init effects\n        sta check_keys_enabled\n        sta check_instr_enabled\n\n\t\t\t\tjsr init_effects\n        \n        jmp start\n\n\n;-------------- end if init code ---------------\n\n\n\n\n\n*=$0c00\nstart\n        lda first_frame_low\n        sta frame_ptr_low\n        lda first_frame_high\n        sta frame_ptr_high\n\n        ; load first frame into back buffer\n        jsr get_next_frame_info\n        jsr tick4\n        lda #$01\n        sta delay_counter\n\n\n        sei             ;disable maskable IRQs\n\n        lda #$00        ; sid tune 0\nsid_init_jsr\n        jsr $1000       ;init_sid\n\n        lda #$7f\n        sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips\n        sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better\n                   ;stop it.\n\n        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.\n        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.\n                   ;we don't want that to happen.\n\n        lda #$01   ;this is how to tell the VICII to generate a raster interrupt\n        sta $d01a\n\n        lda #$ff   ;this is how to tell at which rasterline we want the irq to be triggered\n        sta $d012\n\n        lda $d011  ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as\n        and #$7f   ;the 8th bit for the rasterline we want our irq to be triggered.               \n        sta $d011  ;clear it\n                   \n\n        lda #$35   ;we turn off the BASIC and KERNAL rom here\n        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of\n                   ;SID/VICII/etc are visible\n\n        lda #<irq  ;this is how we set up\n        sta $fffe  ;the address of our interrupt code\n        lda #>irq\n        sta $ffff\n\n        cli        ;enable maskable interrupts again\n\n    \nloop\n        jmp loop\n\n\n        ; ---------------------interrupt start--------------------------------------------\nirq =*\n\n        pha        ;store register A in stack\n        txa\n        pha        ;store register X in stack\n        tya\n        pha        ;store register Y in stack\n\n; 0c51\n\n        lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.\n        sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end\n                   ;up having the CPU running the interrupt code all the time, as when it exists the\n                   ;interrupt, the interrupt request from the VICII will be there again regardless of the\n                   ;rasterline counter.\n\n                   ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they\n                   ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.\n;        inc $d020\n\nsid_play_jsr\n        jsr $1012       ; play sid\n\n        jsr animate_chars\n;        jsr animate_bg_colors\n\n        lda tick                ; cant do trigger stuff if just ticked.\n        beq goto_play_frames\n\n        lda check_keys_enabled\n        beq instrument_triggers    ; if lda is 0, zero flag is set\n\n        jsr check_keys\n\ninstrument_triggers\n        lda check_instr_enabled\n        beq goto_play_frames\n\n        jsr check_instrument\n\ngoto_play_frames\n        jsr play_frames\n\n\nwait_for_raster\n        lda $d011\n        and #$80    ; zero flag is set if zero\n        bne wait_for_raster\n\n        lda $d012\n        cmp #$80\n        bcc wait_for_raster\n\nsid_play_jsr2\n        jsr $1012\n\n;        dec $d020\nirqout\n        pla\n        tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)\n        pla\n        tax        ;restore register X from stack\n        pla        ;restore register A from stack\n\n        rti        ;Return From Interrupt, this will load into the Program Counter register the address\n                   ;where the CPU was when the interrupt condition arised which will make the CPU continue\n                   ;the code it was interrupted at also restores the status register of the CPU\n\n;-----------------------------------------------------------\nplay_frames\n        dec delay_counter\n        bne ticks ; counter not zero yet, do ticks\n\n        lda #$00\n        sta tick\n\n        ; delay is zero, display the next frame...\n        jmp display_next_frame\n\nticks\n;        lda delay_counter \n\n\t\t\t\tjsr effects_tick\n        \n        \n        inc tick\n        lda tick\n        cmp #$01        ;  start preparing for next frame\n        bne tick2test\n        jmp get_next_frame_info\ntick2test        \n        cmp #$02        ;  start preparing for next frame\n        bne tick3test\n        jmp tick4\ntick3test\n        cmp #$03        ;  start preparing for next frame\n        bne tick4test\n        jmp tick3\ntick4test\n        cmp #$04        ;  start preparing for next frame\n        bne tick5test\n        jmp tick2\ntick5test\n        cmp #$05        ;  start preparing for next frame\n        bne tickgreater5\n        jmp tick1\ntickgreater5\n        rts\n\ndisplay_next_frame\n        lda next_char_frame_delay\n        sta delay_counter\n\n        jsr swap_buffers\n\n        ; update colors...\n        lda next_color_frame_bg1\n        sta $d021       ; background color\n        lda next_color_frame_bg2\n        sta $d022       ; background color\n        lda next_color_frame_bg3\n        sta $d023       ; background color\n        lda next_color_frame_bg4\n        sta $d024       ; background color\n\n        ; copy color data\n        lda next_color_frame_addr_low\n        sta copy_from_low\n        lda next_color_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda #$d8\n        sta copy_to_high\n\n\n        lda next_color_frame_type\n        cmp #$01\n        beq whole_frame_color_type             \n\n        ; just copy color changes\n        jsr data_changes\n        jmp read_effects        ; read the effects for this frame\n;        rts \n\nwhole_frame_color_type\n        jsr copy_data_4bit\n        jmp read_effects         ; read the effects for this frame\n;        rts\n\ncheck_trigger_table\n\n        ldy #$00    ; going to use y to loop through keys\n\n        \ncheck_trigger_loop\n\n\n        lda (temp_low),y    ; load in the test key\n        \n        cmp #$00              ; have we reached end of table?\n        beq check_trigger_done   ; reached end, so exit\n\n        iny\n        iny\n        iny\n        iny\n\n        cmp trig            ; check test key against key pressed\n        bne check_trigger_loop\n\n        ; found trigger !\n\n        dey \n        dey\n        dey\n\n        lda (temp_low),y\n        jsr effects_trigger\n\n        lda (temp_low),y\n        beq trigger_goto_frame\n\n        cmp #$02\n        beq switch_charset\n\n\t\t\t\tcmp #$01\n        beq force_next_frame\n        rts\n        \nforce_next_frame        \n        lda #$04\n        sta delay_counter\n;        sta force_next_frame\n        rts\n\nswitch_charset\n        iny\n        lda $d018\n        and #$f1\n        ora (temp_low),y\n        sta $d018\n        rts        \n\ntrigger_goto_frame\n        iny\n        lda (temp_low),y\n        sta frame_ptr_low\n        iny\n\n        lda (temp_low),y\n        sta frame_ptr_high\n\n\n        ; set this as tick 1 so the char data will be copied\n        lda #$00\n        sta tick\n\n\n        ; make the delay counter 4 so the next frame will be disp next tick\n        ;lda #$05\n        lda #$03\n        sta delay_counter\ncheck_trigger_done\n        rts\n\ncheck_keys\n\n        lda #00\n        jsr scan_key\n        sta trig                 ; store the key to check in temp\n\n        lda key_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda key_table_high\n        sta temp_high\n        jsr check_trigger_table\n\n\ncheck_keys_done\n\n\n        rts\n\ncheck_instrument\n\n        lda ch1_newnote\n        cmp #$00\n        beq reset_ch1_new_note\n\n        lda ch1_in_new_note\n        cmp #$00\n        bne ch1nextchannel\n\n        lda #$01\n        sta ch1_in_new_note\n\n        lda ch1_instr\n\n        sta trig                 ; store the instrument to check in temp\n\n        lda instr_table_low        ; load in pointer to keys table\n        sta temp_low\n        lda instr_table_high\n        sta temp_high\n\n\n        jsr check_trigger_table\n\n        rts\n\nreset_ch1_new_note\n        lda #$00\n        sta ch1_in_new_note\n\nch1nextchannel    \n\n        rts\n\nget_next_frame_info\n        ldy #$00\n        lda (frame_ptr_low),y\n\n        ; #$00 indicates a jump\n        cmp #$00\n        bne get_next_frame_info1\n\n        ; next two bytes are where to jump to\n        iny\n        lda (frame_ptr_low),y\n        sta temp  ;frame_ptr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta frame_ptr_high\n\n        lda temp\n        sta frame_ptr_low\n\n        ldy #$00\n\n        lda (frame_ptr_low),y\n\nget_next_frame_info1\n\n        ; read in the next frames info\n\n        sta next_char_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_char_frame_delay\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_type\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_addr_high\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg1\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg2\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg3\n\n        iny\n        lda (frame_ptr_low),y\n        sta next_color_frame_bg4\n\n        ; add y accumulator to frame_ptr\n        tya\n        clc                    ; clear carry\n        adc frame_ptr_low              \n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n\n        lda next_char_frame_type  ; if its the whole frame type, then we're done\n        cmp #$01\n        bne setup_change_frame_type\n        rts\n\nsetup_change_frame_type\n        ; its changes, so need to copy to back buffer\n        jsr copy_front_to_back_buffer\n\n        rts\n\nread_effects\n        ldy #$00\n        ; effects\nread_effects_loop\n        iny\n        lda (frame_ptr_low),y\n\n        ; #$00 means no effects \n        cmp #$00\n        beq frame_info_end\n\n        cmp #$01\n        bne frame_effect_2\n\n        ; enable check keys\n        lda #$01\n        sta check_keys_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta key_table_high\n\n        jmp read_effects_loop\n\nframe_effect_2\n        cmp #$02\n        bne frame_effect_3\n\n        ; disable check keys\n        lda #$00\n        sta check_keys_enabled\n        jmp read_effects_loop\n\nframe_effect_3\n        cmp #$03\n        bne frame_effect_4\n\n        ; enable check instr\n        lda #$01\n        sta check_instr_enabled\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_low\n\n        iny\n        lda (frame_ptr_low),y\n        sta instr_table_high\n\n        jmp read_effects_loop\n\n\n\nframe_effect_4\n        cmp #$04\n        bne frame_effect_5\n\n        ; disable check instruments\n        lda #$00\n        sta check_instr_enabled\n        jmp read_effects_loop\n\nframe_effect_5\n\nframe_info_end\n        iny \n\n        ; add y accumulator to frame_ptr\n        tya\n\n;        sta $d020\n\n        clc                    ; clear carry\n        adc frame_ptr_low                ; add 40 with carry to lower byte\n        sta frame_ptr_low\n\n        lda frame_ptr_high     ; add 0 with carry to higher byte \n        adc #00\n        sta frame_ptr_high\n        rts        \ntick4\n        ; load in location of character data\n        lda next_char_frame_addr_low\n        sta copy_from_low\n        lda next_char_frame_addr_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n\n        ; check what type of frame it is..\n        lda next_char_frame_type\n        cmp #$01\n        beq full_frame_type\n\n        cmp #$02\n        beq changes_frame_type\n\n        ; rle data\n        jsr copy_rle_data\n        rts\n\nchanges_frame_type\n        ; its changes, \n        lda #$00\n        sta frame_finished\n\n        jsr data_changes\n        rts\n\n\nfull_frame_type\n        ; copy all chars to back buffer\n\n        jsr copy_data\n\n        lda #$01\n        sta frame_finished   ; this frame's data is over..\n        rts\n\ntick3\n\n        ; if not finished with changes, continue updating\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick3done\n\n        jsr data_changes\n\ntick3done\n        rts\n\ntick2\n        lda frame_finished  ; finished copying frame data ?\n        cmp #$00\n        bne tick2done\n\n        jsr data_changes\n\ntick2done\n        rts\ntick1\n        rts\n\n\n;------------ end of play frames...\n\ncopy_front_to_back_buffer\n\n        ; copy front buffer to back buffer\n        lda #$00\n        sta copy_from_low\n        lda front_buffer_high\n        sta copy_from_high\n\n        lda #$00\n        sta copy_to_low\n        lda back_buffer_high\n        sta copy_to_high\n\n        jsr copy_data\n\n        rts\n\n\nswap_buffers\n        ldx back_buffer_high         ; load value of current back buffer\n        cpx #$04                     ; is it 0400\n        bne swap_buffers_1\n\n        ; set front buffer to 0400, back buffer to 0800\n        lda #$04\n        sta front_buffer_high\n        lda #$08\n        sta back_buffer_high\n\n        ; set screen location to $0400\n        lda $d018\n        and #$0f\n        ora #$10\n        sta $d018\n\n        rts\n\nswap_buffers_1\n        ; set front buffer to 0800, back buffer to 0400\n        lda #$08\n        sta front_buffer_high\n        lda #$04\n        sta back_buffer_high\n\n        ; set screen location to $0800\n        lda $d018\n        and #$0f\n        ora #$20\n        sta $d018\n\n        rts\n\n\ncopy_data\n;        ldy xoffset\n        ldy #$0\n        ldx #25    ; number of lines to copy\n\n\ncopy_data_line\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_line\n        \n        dex\n        beq copy_data_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_line\n\ncopy_data_done\n\n        rts \n\n\ncopy_data_4bit\n        ldy #0\n        ldx #25\n\ncopy_data_4bit_line\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y \n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n;        lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n        lda (copy_from_low),y\n        sta (copy_to_low),y\n        iny\n        lsr\n        lsr\n        lsr\n        lsr\n        ;lda (copy_from_low),y\n        sta (copy_to_low),y\n\n        iny\n\n\n        cpy #40                 ; have we copied 40 chars? (10x4)\n        bne copy_data_4bit_line\n        \n        dex\n        beq copy_data_4bit_done\n        \n        ldy #0                  ; back to start of line\n\n\n        ; increase where copy from by 40\n        clc                    ; clear carry\n        lda copy_from_low\n        adc #40                ; add 40 with carry to lower byte\n        sta copy_from_low\n\n        lda copy_from_high     ; add 0 with carry to higher byte \n        adc #00\n        sta copy_from_high\n\n\n        ; increase where copy to by 40\n        clc                     ; clear carry\n        lda copy_to_low\n        adc #40                 ; add 40 with carry to lower byte\n        sta copy_to_low\n\n        lda copy_to_high        ; add 0 with carry to higher byte \n        adc #00\n        sta copy_to_high\n\n        jmp copy_data_4bit_line\n\ncopy_data_4bit_done\n\n        rts \n\n\n\ncopy_rle_data\n        ldy #00\n\n        lda (copy_from_low),y\n        bne continue_rle\n\n        ; reached the end of the data\n        lda #$01\n        sta frame_finished\n\n        rts\n\ncontinue_rle\n        tax\n\n        inc copy_from_low\n        bne rle_get_byte\n        inc copy_from_high\n\nrle_get_byte\n        lda (copy_from_low),y\n        inc copy_from_low\n        bne write_rle_byte\n        inc copy_from_high\n\n\nwrite_rle_byte        \n        sta (copy_to_low),y\n        iny\n        dex\n        bne write_rle_byte\n\n        tya\n\n        clc\n        adc copy_to_low\n        sta copy_to_low\n\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n        jmp copy_rle_data\n\n\n\n\n; data changes are list:  offset, change, offset, change, ends in 00\ndata_changes\n        ldx #$00\n\n        ldy #$00\n        lda (copy_from_low),y      ; load the first offset\n\nnext_change              \n        ; add the offset to buffer ptr\n        clc\n        adc copy_to_low\n\n        sta copy_to_low\n        lda copy_to_high\n        adc #$00\n        sta copy_to_high\n\n\n        ; increase the pointer to the change data\n        inc copy_from_low     ; zero flag will be set if result is zero\n        bne get_change\n        inc copy_from_high\nget_change\n\n\n\n        lda (copy_from_low),y      ; load the character\n        sta (copy_to_low),y \n\n\n        ; increase the pointer to the change data\n        inc copy_from_low           ; zero flag will be set if result is zero\n        bne get_offset\n        inc copy_from_high\n\nget_offset         \n        lda (copy_from_low),y\n\n        cmp #$0                     ; sequence ends with a 0 offset\n        beq changes_done\n\n\n        inx\n        cpx #$ff                    ; only do up to 255 changes\n        bne next_change\n\n        ; reached max number of changes for this refresh... mark as not finished yet\n        lda #$00\n        sta frame_finished\n        rts\n\nchanges_done        \n        \n        lda #$01                        ; mark frame as finished..\n        sta frame_finished\n\n        rts\n\n\n*= $4000\n\nanimate_chars\n\n;  inc $d020\n;  rts\n  lda #$38\n  sta copy_to_high2\n  lda #$00\n  sta copy_to_low2\n  \n\n  \n  lda animated_chars_table_low\n  sta copy_from_low2\n  \n  lda animated_chars_table_high\n  sta copy_from_high2\n  \n  \nanim_char_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_chars_done\n  \n  ldy #$01\n  lda (copy_from_low2), y\n  tax\n  dex\n  txa\n  sta (copy_from_low2), y\n  \n  bne next_anim_char\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low2), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low2), y\n  \n  ; load in character to animate\n  iny\n\n\t; get character offset\n  lda (copy_from_low2), y\n  \n  clc                    ; clear carry\n  adc copy_to_low2              \n  sta temp_low\n\n\t\n  iny\n  lda (copy_from_low2),y\n  adc copy_to_high2\n  sta temp_high\n  \n  ; get the animation type\n  iny\n  lda (copy_from_low2),y\n  \n  cmp #$00\n  bne anim_type_1\n\tjsr scroll_char_left\n\tjmp next_anim_char\nanim_type_1\n  cmp #$01\n  bne anim_type_2\n  jsr scroll_char_right\n  jmp next_anim_char\nanim_type_2\n\tcmp #$02\n  bne anim_type_3\n  jsr scroll_char_up\n  jmp next_anim_char\nanim_type_3\n\tcmp #$03\n  bne anim_type_4\n  jsr scroll_char_down\n  jmp next_anim_char\n\nanim_type_4\n  jsr blink_char\n  \nnext_anim_char\n\n\tclc\n  \n\t; add 5 to animated char table ptr\n\tlda copy_from_low2\n  adc #$05              \n  sta copy_from_low2\n\n\tlda copy_from_high2     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high2\n  \n  jmp anim_char_start\n\n\n\nanimate_chars_done\n\n;  dec $d020\n\t\n\trts\n  \nblink_char\n\tldy #$00\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\tlda #$ff\n  eor (temp_low),y\n  sta (temp_low),y\n  iny\n\n\trts\n  \nscroll_char_down\n\n\tldy #$07\n  lda (temp_low),y\n  sta temp\n  \n  dey\n  ; 3806\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n  \n  ; 3805\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3804\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3803\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3802\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3801\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  dey\n\n  ; 3800\n  lda (temp_low),y\n  iny\n  sta (temp_low),y\n  dey\n  \n\tlda temp\n  sta (temp_low), y\n\n;\tlda $3800\n;  sta temp\n  \n;  lda $3807\n;  sta $3800\n\n;  lda $3806\n;  sta $3807\n\n;  lda $3805\n;  sta $3806\n;  lda $3804\n;  sta $3805\n;  lda $3803\n;  sta $3804\n;  lda $3802\n;  sta $3803\n;  lda $3801\n;  sta $3802\n;  lda temp\n;  sta $3801\n\n\trts\n\n\nscroll_char_up\n\tldy #$00\n\tlda (temp_low), y\n  sta temp\n  \n  iny\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n  iny\n\n  lda (temp_low), y\n  dey\n  sta (temp_low), y\n  iny\n\n\tlda temp\n  sta (temp_low), y\n\n\trts\n  \nscroll_char_right\n\tldy #$00\n  ldx #$08\n\nscroll_char_right_cont\n  dex\n\n\tlda temp_low\n  sta scroll_char_right_addr1 + 1\n  sta scroll_char_right_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_right_addr1 + 2\n  sta scroll_char_right_addr2 + 2\n\n\nscroll_char_right_addr1\n\tlda $3800,x\n  ror\nscroll_char_right_addr2\n  ror $3800,x\n  \n  txa\n  cmp #$00\n  bne scroll_char_right_cont\n\n\trts\n\nscroll_char_left\n\tldy #$00\n  ldx #$08\n  \n\n\tlda temp_low\n  sta scroll_char_left_addr1 + 1\n  sta scroll_char_left_addr2 + 1\n\n\tlda temp_high\n  sta scroll_char_left_addr1 + 2\n  sta scroll_char_left_addr2 + 2\n  \nscroll_char_left_cont\n\n\n  dex\n\n\nscroll_char_left_addr1\n\tlda $3800,x\n  rol\nscroll_char_left_addr2\n  rol $3800,x\n\n\ttxa\n  cmp #$00\n\tbne scroll_char_left_cont\n  \n  rts\n\nanimate_bg_colors\n;\tinc $d021\n;  inc $d022\n;  inc $d023\n;  inc $d024\n \n  lda #$d0\n  sta copy_to_high\n  lda #$21\n  sta copy_to_low\n  \n  lda animated_bg_colors_table_low\n  sta copy_from_low\n  \n  lda animated_bg_colors_table_high\n  sta copy_from_high\n  \n  \nanim_bg_color_start\n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; if value is 0 then reached end of table\n  cmp #$00\n  beq animate_bg_colors_done\n  \n  ldy #$01\n  lda (copy_from_low), y\n  tax\n  dex\n  txa\n  sta (copy_from_low), y\n  \n  bne next_anim_bg_color\n  \n  \n  ; counter has reached 0\n  \n  ; load number of ticks per frame\n  ldy #$00\n  lda (copy_from_low), y\n  \n  ; store in counter for the character\n  iny\n  sta (copy_from_low), y\n  \n  ; load in color to animate\n  iny\n  lda (copy_from_low), y\n  \n  \n  \n  clc                    ; clear carry\n  adc copy_to_low              \n  sta temp_low\n  \n  lda #$00\n  adc copy_to_high\n  sta temp_high\n  \n  ldy #$00\n  lda (temp_low), y\n  adc #$01\n;  inc \n  sta (temp_low), y\n  \n  \n\nnext_anim_bg_color\n\n\tclc\n  \n\t; add 3 to animated char table ptr\n\tlda copy_from_low\n  adc #$03              \n  sta copy_from_low\n\n\tlda copy_from_high     ; add 0 with carry to higher byte \n\tadc #00\n  sta copy_from_high\n  \n  jmp anim_bg_color_start\n\n\n\nanimate_bg_colors_done\n\n;  dec $d020\n\t\n\trts\n  \n\n  \nscan_key\n\n;    inc $d020\n\n    ;; set up the data direction registers\n    lda #$0\n    sta $dc03   ; port b ddr (input)\n    lda #$ff\n    sta $dc02   ; port a ddr (output)\n            \n    ; set which row being checked\n    lda #$00\n    sta $dc00   ; port a\n\n    lda $dc01\n    sta $11\n\n    ; get column information\n    lda $dc01       ; port b\n\n    cmp #$ff\n    beq nokey\n\n    ; got column\n    tay\n    \n\n    ; first row to test        \n    lda #$7f      ;  0111 1111\n    sta nokey2+1\n\n    ; going to check 8 rows\n    ldx #8\nnokey2\n    ;; this location has the row to check\n    lda #0\n    sta $dc00   ; port a\n    \n    ; set the carry flag\n    sec\n    ; set next row to check\n    ror nokey2+1\n\n    ; checked all rows yet?\n    dex\n    ; branch if minus\n    bmi nokey\n\n    ; get column information\n    lda $dc01       ; port b\n    cmp #$ff\n    beq nokey2\n            \n    ; got row in X\n    txa\n    sta $12\n    ora columntab,y\n\n    sta $10\n\n    sec\n    \n;    dec $d020\n    rts\n            \nnokey\n    clc\n;    dec $d020\n    lda #$0\n    sta $10\n\n    rts\n\n\ncolumntab\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$70\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$60\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$50\n\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$40\n!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$30\n!byte $ff,$ff,$ff,$20,$ff,$10,$00,$ff\n\ninit_effects\n\trts\n\n";

var C64ASM = function() {
  this.files = null;

}

C64ASM.prototype = {
  init: function(editor) {
    this.editor = editor;

    this.files = new AssemblerFiles();

    var main = this.files.createFile('/main.asm');
    main.setContent(C64ASMSource);

/*
    var index = files.createFile('/index.asm');
    index.setContent('hello');

    var content = files.load('/index.asm');
    console.log('content = ' + content);

    var folder = files.createFolder("/src");
    var file = folder.createFile("hello.asm");
    file.setContent("this is the content for hello");

    console.log('content = ' + files.load('/src/hello.asm'));
*/

  },

  editCode: function() {
    g_app.assemblerEditor.setFiles(this.files);
    g_app.showAssembler();
  }
}